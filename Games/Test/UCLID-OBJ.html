<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Non-Euclidean FPS</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: 'Courier New', monospace;
            background: #000;
        }
        
        canvas {
            display: block;
        }
        
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: #0f0;
            border: 1px solid #000;
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 0 10px #0f0;
        }
        
        #ui {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #0f0;
            font-size: 18px;
            text-shadow: 2px 2px 4px #000;
            z-index: 100;
            font-weight: bold;
        }
        
        #weapon-stats {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #0f0;
            font-size: 16px;
            text-shadow: 2px 2px 4px #000;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 2px solid #0f0;
            min-width: 200px;
        }
        
        #weapon-stats h3 {
            margin: 0 0 10px 0;
            font-size: 20px;
            color: #0ff;
        }
        
        .stat-bar {
            margin: 8px 0;
        }
        
        .stat-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
            font-size: 14px;
        }
        
        .stat-bar-bg {
            width: 100%;
            height: 8px;
            background: #002200;
            border: 1px solid #0f0;
            position: relative;
            overflow: hidden;
        }
        
        .stat-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #0f0, #0ff);
            transition: width 0.3s ease;
        }
        
        #morph-timer {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #0f0;
            text-align: center;
            font-size: 14px;
        }
        
        #morph-progress {
            width: 100%;
            height: 6px;
            background: #002200;
            border: 1px solid #0f0;
            margin-top: 5px;
            position: relative;
            overflow: hidden;
        }
        
        #morph-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0, #f00);
            transition: width 0.1s linear;
        }
        
        .morphing {
            animation: morph-flash 0.5s ease-in-out;
        }
        
        @keyframes morph-flash {
            0%, 100% { 
                border-color: #0f0;
                box-shadow: 0 0 10px #0f0;
            }
            50% { 
                border-color: #ff0;
                box-shadow: 0 0 30px #ff0;
            }
        }
        
        #instructions {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0f0;
            font-size: 24px;
            text-align: center;
            text-shadow: 2px 2px 8px #000;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 40px;
            border: 2px solid #0f0;
        }
        
        #instructions.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="ui">
        <div>AMMO: <span id="ammo">30/30</span></div>
        <div>HEALTH: <span id="health">100</span></div>
    </div>
    
    <div id="weapon-stats">
        <h3>WEAPON MORPH</h3>
        
        <div class="stat-bar">
            <div class="stat-label">
                <span>DAMAGE</span>
                <span id="damage-val">25</span>
            </div>
            <div class="stat-bar-bg">
                <div class="stat-bar-fill" id="damage-bar"></div>
            </div>
        </div>
        
        <div class="stat-bar">
            <div class="stat-label">
                <span>FIRE RATE</span>
                <span id="firerate-val">50</span>
            </div>
            <div class="stat-bar-bg">
                <div class="stat-bar-fill" id="firerate-bar"></div>
            </div>
        </div>
        
        <div class="stat-bar">
            <div class="stat-label">
                <span>PROJ SPEED</span>
                <span id="speed-val">45</span>
            </div>
            <div class="stat-bar-bg">
                <div class="stat-bar-fill" id="speed-bar"></div>
            </div>
        </div>
        
        <div class="stat-bar">
            <div class="stat-label">
                <span>SPREAD</span>
                <span id="spread-val">5°</span>
            </div>
            <div class="stat-bar-bg">
                <div class="stat-bar-fill" id="spread-bar"></div>
            </div>
        </div>
        
        <div class="stat-bar">
            <div class="stat-label">
                <span>MAG SIZE</span>
                <span id="mag-val">30</span>
            </div>
            <div class="stat-bar-bg">
                <div class="stat-bar-fill" id="mag-bar"></div>
            </div>
        </div>
        
        <div id="morph-timer">
            NEXT MORPH: <span id="morph-countdown">4.0s</span>
            <div id="morph-progress">
                <div id="morph-progress-fill"></div>
            </div>
        </div>
    </div>
    
    <div id="instructions">
        <h2>NON-EUCLIDEAN FPS</h2>
        <p style="margin-top: 20px;">WASD - Move</p>
        <p>SPACE - Jump</p>
        <p>MOUSE - Look</p>
        <p>LEFT CLICK - Shoot</p>
        <p>R - Reload</p>
        <p>M - Regenerate Map</p>
        <p style="margin-top: 30px; font-size: 18px;">Click to start</p>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game state
        const game = {
            locked: false,
            health: 100,
            weapon: {
                damage: 25,
                fireRate: 150,
                projectileSpeed: 45,
                spread: 5,
                magSize: 30,
                ammo: 30,
                maxAmmo: 30,
                lastShot: 0,
                reloading: false
            },
            morphTimer: 0,
            morphInterval: 4000, // 4 seconds between morphs
            lastMorphTime: Date.now()
        };
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        scene.fog = new THREE.Fog(0x0a0a0a, 20, 80);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // Player movement
        const player = {
            velocity: new THREE.Vector3(),
            direction: new THREE.Vector3(),
            canJump: false,
            height: 1.8,
            speed: 0.15,
            jumpVelocity: 0.3
        };
        
        const keys = {};
        const moveDirection = new THREE.Vector3();
        
        // Camera rotation
        let pitch = 0;
        let yaw = 0;
        const pitchObject = new THREE.Object3D();
        const yawObject = new THREE.Object3D();
        pitchObject.add(camera);
        yawObject.add(pitchObject);
        scene.add(yawObject);
        yawObject.position.y = player.height;
        
        // Procedural map generation
        const mapData = {
            gridSize: 10, // Size of grid cells
            mapWidth: 15, // Grid units
            mapDepth: 15,
            cells: [],
            rooms: [],
            corridors: [],
            seed: Math.random()
        };
        
        // Clear existing map objects
        function clearMap() {
            const objectsToRemove = [];
            scene.children.forEach(obj => {
                if (obj.type === 'Mesh' || obj.type === 'PointLight') {
                    if (obj !== camera && !obj.isAmbientLight && !obj.isDirectionalLight) {
                        objectsToRemove.push(obj);
                    }
                }
            });
            objectsToRemove.forEach(obj => scene.remove(obj));
        }
        
        // Regenerate entire map
        function regenerateMap() {
            clearMap();
            mapData.seed = Math.random();
            createEnvironment();
        }
        
        // Simple seeded random
        function seededRandom(seed) {
            const x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        }
        
        // Generate room-based dungeon layout
        function generateMapLayout() {
            const grid = [];
            const w = mapData.mapWidth;
            const d = mapData.mapDepth;
            
            // Initialize empty grid
            for (let z = 0; z < d; z++) {
                grid[z] = [];
                for (let x = 0; x < w; x++) {
                    grid[z][x] = 0; // 0 = empty, 1 = floor, 2 = wall
                }
            }
            
            mapData.rooms = [];
            let seed = mapData.seed;
            
            // Generate random rooms
            const numRooms = 8 + Math.floor(seededRandom(seed++) * 6);
            
            for (let i = 0; i < numRooms; i++) {
                const roomWidth = 3 + Math.floor(seededRandom(seed++) * 5);
                const roomDepth = 3 + Math.floor(seededRandom(seed++) * 5);
                const roomX = Math.floor(seededRandom(seed++) * (w - roomWidth - 2)) + 1;
                const roomZ = Math.floor(seededRandom(seed++) * (d - roomDepth - 2)) + 1;
                
                // Check if room overlaps with existing rooms
                let overlaps = false;
                for (let z = roomZ - 1; z < roomZ + roomDepth + 1; z++) {
                    for (let x = roomX - 1; x < roomX + roomWidth + 1; x++) {
                        if (z >= 0 && z < d && x >= 0 && x < w && grid[z][x] === 1) {
                            overlaps = true;
                            break;
                        }
                    }
                    if (overlaps) break;
                }
                
                if (!overlaps) {
                    // Place room
                    for (let z = roomZ; z < roomZ + roomDepth; z++) {
                        for (let x = roomX; x < roomX + roomWidth; x++) {
                            grid[z][x] = 1;
                        }
                    }
                    
                    mapData.rooms.push({
                        x: roomX,
                        z: roomZ,
                        width: roomWidth,
                        depth: roomDepth,
                        centerX: roomX + Math.floor(roomWidth / 2),
                        centerZ: roomZ + Math.floor(roomDepth / 2)
                    });
                }
            }
            
            // Connect rooms with corridors
            for (let i = 0; i < mapData.rooms.length - 1; i++) {
                const roomA = mapData.rooms[i];
                const roomB = mapData.rooms[i + 1];
                
                // Create L-shaped corridor
                let x = roomA.centerX;
                let z = roomA.centerZ;
                
                while (x !== roomB.centerX) {
                    if (x >= 0 && x < w && z >= 0 && z < d) {
                        grid[z][x] = 1;
                    }
                    x += (roomB.centerX > x) ? 1 : -1;
                }
                
                while (z !== roomB.centerZ) {
                    if (x >= 0 && x < w && z >= 0 && z < d) {
                        grid[z][x] = 1;
                    }
                    z += (roomB.centerZ > z) ? 1 : -1;
                }
            }
            
            mapData.cells = grid;
            return grid;
        }
        
        // Create 3D geometry from map layout
        function createEnvironment() {
            const grid = generateMapLayout();
            const cellSize = mapData.gridSize;
            
            // Floor and ceiling materials
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a,
                roughness: 0.9
            });
            
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.7
            });
            
            // Generate walls and floors
            for (let z = 0; z < mapData.mapDepth; z++) {
                for (let x = 0; x < mapData.mapWidth; x++) {
                    const worldX = (x - mapData.mapWidth / 2) * cellSize;
                    const worldZ = (z - mapData.mapDepth / 2) * cellSize;
                    
                    if (grid[z][x] === 1) {
                        // Create floor tile
                        const floorGeom = new THREE.PlaneGeometry(cellSize, cellSize);
                        const floor = new THREE.Mesh(floorGeom, floorMaterial);
                        floor.rotation.x = -Math.PI / 2;
                        floor.position.set(worldX, 0, worldZ);
                        floor.receiveShadow = true;
                        scene.add(floor);
                        
                        // Check adjacent cells for walls
                        const checks = [
                            { dx: 0, dz: -1, rotY: 0 },        // North
                            { dx: 1, dz: 0, rotY: Math.PI / 2 }, // East
                            { dx: 0, dz: 1, rotY: Math.PI },    // South
                            { dx: -1, dz: 0, rotY: -Math.PI / 2 } // West
                        ];
                        
                        checks.forEach(check => {
                            const adjX = x + check.dx;
                            const adjZ = z + check.dz;
                            
                            // Place wall if adjacent cell is empty or out of bounds
                            if (adjX < 0 || adjX >= mapData.mapWidth || 
                                adjZ < 0 || adjZ >= mapData.mapDepth || 
                                grid[adjZ][adjX] === 0) {
                                
                                const wallHeight = 4 + Math.random() * 2;
                                const wallGeom = new THREE.BoxGeometry(cellSize, wallHeight, 0.5);
                                const wall = new THREE.Mesh(wallGeom, wallMaterial.clone());
                                
                                // Position wall at edge of cell
                                const offsetX = check.dx * cellSize / 2;
                                const offsetZ = check.dz * cellSize / 2;
                                wall.position.set(worldX + offsetX, wallHeight / 2, worldZ + offsetZ);
                                wall.rotation.y = check.rotY;
                                wall.castShadow = true;
                                wall.receiveShadow = true;
                                scene.add(wall);
                            }
                        });
                    }
                }
            }
            
            // Add pillars in rooms
            const pillarMaterial = new THREE.MeshStandardMaterial({
                color: 0x555555,
                roughness: 0.6
            });
            
            mapData.rooms.forEach((room, idx) => {
                let seed = mapData.seed + idx * 100;
                
                // Random decorations per room
                const numPillars = Math.floor(seededRandom(seed++) * 3);
                for (let i = 0; i < numPillars; i++) {
                    const pillarX = (room.x + 1 + Math.floor(seededRandom(seed++) * (room.width - 2)) - mapData.mapWidth / 2) * cellSize;
                    const pillarZ = (room.z + 1 + Math.floor(seededRandom(seed++) * (room.depth - 2)) - mapData.mapDepth / 2) * cellSize;
                    const pillarHeight = 3 + seededRandom(seed++) * 3;
                    
                    const pillar = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.5, 0.8, pillarHeight, 8),
                        pillarMaterial
                    );
                    pillar.position.set(pillarX, pillarHeight / 2, pillarZ);
                    pillar.castShadow = true;
                    pillar.receiveShadow = true;
                    scene.add(pillar);
                }
                
                // Add target boxes in rooms
                const numTargets = 1 + Math.floor(seededRandom(seed++) * 3);
                for (let i = 0; i < numTargets; i++) {
                    const targetX = (room.x + Math.floor(seededRandom(seed++) * room.width) - mapData.mapWidth / 2) * cellSize;
                    const targetZ = (room.z + Math.floor(seededRandom(seed++) * room.depth) - mapData.mapDepth / 2) * cellSize;
                    const size = 0.8 + seededRandom(seed++) * 1.2;
                    
                    const target = new THREE.Mesh(
                        new THREE.BoxGeometry(size, size, size),
                        new THREE.MeshStandardMaterial({ 
                            color: 0xff0000,
                            roughness: 0.5
                        })
                    );
                    target.position.set(targetX, size / 2, targetZ);
                    target.castShadow = true;
                    target.receiveShadow = true;
                    target.userData.isTarget = true;
                    scene.add(target);
                }
            });
            
            // Add ambient lighting to rooms
            mapData.rooms.forEach(room => {
                const lightX = (room.centerX - mapData.mapWidth / 2) * cellSize;
                const lightZ = (room.centerZ - mapData.mapDepth / 2) * cellSize;
                
                const roomLight = new THREE.PointLight(0x4488ff, 0.5, 20);
                roomLight.position.set(lightX, 3, lightZ);
                scene.add(roomLight);
            });
            
            // Spawn player in first room
            if (mapData.rooms.length > 0) {
                const spawnRoom = mapData.rooms[0];
                const spawnX = (spawnRoom.centerX - mapData.mapWidth / 2) * cellSize;
                const spawnZ = (spawnRoom.centerZ - mapData.mapDepth / 2) * cellSize;
                yawObject.position.set(spawnX, player.height, spawnZ);
            }
        }
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        scene.add(directionalLight);
        
        // Muzzle flash
        const muzzleFlash = new THREE.PointLight(0xffff00, 0, 5);
        camera.add(muzzleFlash);
        muzzleFlash.position.set(0.3, -0.2, -0.5);
        
        // Weapon morphing system
        function morphWeapon() {
            const w = game.weapon;
            
            // Randomly generate new stats within ranges
            w.damage = Math.floor(5 + Math.random() * 90); // 5-95
            w.fireRate = Math.floor(100 + Math.random() * 1900); // 100-2000ms
            w.projectileSpeed = Math.floor(10 + Math.random() * 70); // 10-80
            w.spread = Math.floor(Math.random() * 16); // 0-15 degrees
            w.magSize = Math.floor(3 + Math.random() * 28); // 3-30
            
            // Refill ammo on morph
            w.maxAmmo = w.magSize;
            w.ammo = w.maxAmmo;
            w.reloading = false;
            
            // Visual feedback
            const statsPanel = document.getElementById('weapon-stats');
            statsPanel.classList.add('morphing');
            setTimeout(() => statsPanel.classList.remove('morphing'), 500);
            
            // Camera shake
            const originalY = camera.position.y;
            const shakeIntensity = 0.1;
            const shakeDuration = 200;
            const shakeStart = Date.now();
            
            function shake() {
                const elapsed = Date.now() - shakeStart;
                if (elapsed < shakeDuration) {
                    camera.position.y = originalY + (Math.random() - 0.5) * shakeIntensity;
                    requestAnimationFrame(shake);
                } else {
                    camera.position.y = originalY;
                }
            }
            shake();
            
            updateWeaponStatsUI();
            updateUI();
        }
        
        // Update weapon stats UI
        function updateWeaponStatsUI() {
            const w = game.weapon;
            
            // Update values and bars
            document.getElementById('damage-val').textContent = w.damage;
            document.getElementById('damage-bar').style.width = ((w.damage - 5) / 90 * 100) + '%';
            
            // Fire rate is inverse (lower is better), so invert the bar
            const fireRateNormalized = 100 - ((w.fireRate - 100) / 1900 * 100);
            document.getElementById('firerate-val').textContent = Math.floor(60000 / w.fireRate) + ' RPM';
            document.getElementById('firerate-bar').style.width = fireRateNormalized + '%';
            
            document.getElementById('speed-val').textContent = w.projectileSpeed;
            document.getElementById('speed-bar').style.width = ((w.projectileSpeed - 10) / 70 * 100) + '%';
            
            // Spread is inverse (lower is better)
            document.getElementById('spread-val').textContent = w.spread + '°';
            document.getElementById('spread-bar').style.width = (100 - (w.spread / 15 * 100)) + '%';
            
            document.getElementById('mag-val').textContent = w.magSize;
            document.getElementById('mag-bar').style.width = ((w.magSize - 3) / 27 * 100) + '%';
        }
        
        // Shooting
        const projectiles = [];
        
        function shoot() {
            const now = Date.now();
            if (now - game.weapon.lastShot < game.weapon.fireRate) return;
            if (game.weapon.ammo <= 0) return;
            if (game.weapon.reloading) return;
            
            game.weapon.ammo--;
            game.weapon.lastShot = now;
            updateUI();
            
            // Muzzle flash
            muzzleFlash.intensity = 10;
            setTimeout(() => muzzleFlash.intensity = 0, 50);
            
            // Apply spread
            const spreadRad = (game.weapon.spread * Math.PI / 180);
            const spreadX = (Math.random() - 0.5) * spreadRad;
            const spreadY = (Math.random() - 0.5) * spreadRad;
            
            // Raycast for hit detection with spread
            const raycaster = new THREE.Raycaster();
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
            
            // Apply spread to direction
            const spreadQuaternion = new THREE.Quaternion();
            spreadQuaternion.setFromEuler(new THREE.Euler(spreadY, spreadX, 0));
            direction.applyQuaternion(spreadQuaternion);
            
            raycaster.set(camera.getWorldPosition(new THREE.Vector3()), direction);
            
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            // Create bullet trail
            const bulletGeometry = new THREE.BufferGeometry();
            const bulletMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
            
            const start = camera.getWorldPosition(new THREE.Vector3());
            let end = start.clone().add(direction.multiplyScalar(100));
            
            if (intersects.length > 0) {
                const hit = intersects[0];
                end = hit.point;
                
                // Hit effect
                if (hit.object.userData.isTarget) {
                    const originalColor = hit.object.material.color.clone();
                    hit.object.material.color.set(0xffffff);
                    setTimeout(() => {
                        hit.object.material.color.copy(originalColor);
                    }, 100);
                    
                    // Apply physics impulse based on projectile speed
                    const impulse = direction.clone().multiplyScalar(game.weapon.projectileSpeed * 0.02);
                    hit.object.position.add(impulse);
                }
                
                // Impact spark
                const sparkGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const sparkMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                spark.position.copy(hit.point);
                scene.add(spark);
                setTimeout(() => scene.remove(spark), 100);
            }
            
            const positions = new Float32Array([
                start.x, start.y, start.z,
                end.x, end.y, end.z
            ]);
            bulletGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const bulletTrail = new THREE.Line(bulletGeometry, bulletMaterial);
            scene.add(bulletTrail);
            setTimeout(() => scene.remove(bulletTrail), 100);
        }
        
        function reload() {
            if (game.weapon.reloading) return;
            if (game.weapon.ammo === game.weapon.maxAmmo) return;
            
            game.weapon.reloading = true;
            setTimeout(() => {
                game.weapon.ammo = game.weapon.maxAmmo;
                game.weapon.reloading = false;
                updateUI();
            }, 1500);
        }
        
        // Input handling
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'KeyR') reload();
            if (e.code === 'KeyM' && game.locked) regenerateMap();
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        document.addEventListener('mousedown', (e) => {
            if (!game.locked) return;
            if (e.button === 0) shoot();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!game.locked) return;
            
            const movementX = e.movementX || 0;
            const movementY = e.movementY || 0;
            
            yaw -= movementX * 0.002;
            pitch -= movementY * 0.002;
            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
            
            pitchObject.rotation.x = pitch;
            yawObject.rotation.y = yaw;
        });
        
        // Pointer lock
        const instructions = document.getElementById('instructions');
        
        document.addEventListener('click', () => {
            if (!game.locked) {
                document.body.requestPointerLock();
            }
        });
        
        document.addEventListener('pointerlockchange', () => {
            game.locked = document.pointerLockElement === document.body;
            instructions.classList.toggle('hidden', game.locked);
        });
        
        // Update UI
        function updateUI() {
            document.getElementById('ammo').textContent = 
                `${game.weapon.ammo}/${game.weapon.maxAmmo}${game.weapon.reloading ? ' [RELOADING...]' : ''}`;
            document.getElementById('health').textContent = game.health;
        }
        
        // Game loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (game.locked) {
                // Update morph timer
                const now = Date.now();
                const timeSinceLastMorph = now - game.lastMorphTime;
                const timeUntilNextMorph = game.morphInterval - timeSinceLastMorph;
                
                if (timeUntilNextMorph <= 0) {
                    morphWeapon();
                    game.lastMorphTime = now;
                } else {
                    // Update countdown display
                    const secondsLeft = (timeUntilNextMorph / 1000).toFixed(1);
                    document.getElementById('morph-countdown').textContent = secondsLeft + 's';
                    
                    // Update progress bar
                    const progress = (timeSinceLastMorph / game.morphInterval) * 100;
                    document.getElementById('morph-progress-fill').style.width = progress + '%';
                }
                
                // Movement
                moveDirection.set(0, 0, 0);
                
                if (keys['KeyW']) moveDirection.z -= 1;
                if (keys['KeyS']) moveDirection.z += 1;
                if (keys['KeyA']) moveDirection.x -= 1;
                if (keys['KeyD']) moveDirection.x += 1;
                
                moveDirection.normalize();
                moveDirection.applyQuaternion(yawObject.quaternion);
                moveDirection.y = 0;
                
                player.velocity.x = moveDirection.x * player.speed;
                player.velocity.z = moveDirection.z * player.speed;
                
                // Gravity
                player.velocity.y -= 0.01;
                
                // Jump
                if (keys['Space'] && player.canJump) {
                    player.velocity.y = player.jumpVelocity;
                    player.canJump = false;
                }
                
                // Apply velocity
                yawObject.position.add(player.velocity);
                
                // Ground collision
                if (yawObject.position.y < player.height) {
                    yawObject.position.y = player.height;
                    player.velocity.y = 0;
                    player.canJump = true;
                }
            }
            
            renderer.render(scene, camera);
        }
        
        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize
        createEnvironment();
        updateUI();
        updateWeaponStatsUI();
        animate();
    </script>
</body>
</html>